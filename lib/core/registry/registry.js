"use strict";var e=this&&this.__awaiter||function(e,t,r,o){return new(r||(r=Promise))((function(n,i){function s(e){try{u(o.next(e))}catch(e){i(e)}}function a(e){try{u(o.throw(e))}catch(e){i(e)}}function u(e){var t;e.done?n(e.value):(t=e.value,t instanceof r?t:new r((function(e){e(t)}))).then(s,a)}u((o=o.apply(e,t||[])).next())}))},t=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.checkRegistry=exports.getUserAgent=exports.getDownloadRegistry=exports.publishPackage=exports.unpublishPackage=exports.getFetchTimeout=exports.fetchPackage=exports.fetchPackageInfo=exports.getAuditRegistry=exports.getPublishRegistry=exports.getRegistryList=void 0;const r=t(require("node-fetch")),o=t(require("../../log")),n=require("../../config"),i=require("./proxy"),s=require("../../util"),a=t(require("crypto")),u=require("uuid"),c=t(require("readline-sync")),f=t(require("fs-extra")),g=require("../../config/DefaultConfig"),d=require("../../common/Constants"),l=require("../../common/ohpm.config");function p(e){return e.endsWith("/")?e:`${e}/`}function h(e){var t,r;let i="";if(-1!==e.indexOf("/")&&e.startsWith("@")){const r=e.split("/")[0];i=null===(t=n.config.getString(`${r}:registry`))||void 0===t?void 0:t.trim()}if(i||(i=null===(r=n.config.getString(n.types.REGISTRY))||void 0===r?void 0:r.trim()),i||(i=g.defaultConfig.registry),!i)throw o.default.error("",'The registry is empty - edit .ohpmrc file or use "ohpm config set registry your_registry" command to set registry.'),"";const s=[],a=i.split(",");for(const e of a){const t=e.trim();t&&s.push(p(t))}return s}exports.getRegistryList=h,exports.getPublishRegistry=function(){const e=n.config.getString("publish_registry");return e?p(e):""},exports.getAuditRegistry=function(){let e=n.config.getString("registry");if(!e)return"";const t=e.split(",");return 0===t.length?"":(e=t[0],e?p(e):"")};const y=new Map;exports.fetchPackageInfo=function(t){return e(this,void 0,void 0,(function*(){const e=h(t);for(const n of e){const e=`${n}${t}`;try{const s=yield(0,r.default)(e,{agent:(0,i.getProxyAgent)(n),timeout:$(),redirect:"error"});if(s.ok)return y.set(t,n),o.default.info(`fetch meta info of package '${t}' success`,e),s.json();o.default.info(`fetch meta info of package '${t}' failed`,`- GET ${e} ${s.status}`)}catch(e){if(d.Constants.errnoList.includes(e.errno))throw o.default.error(e.errno,e.message),new Error(e.message);if(d.Constants.errTypeMap[e.type])throw o.default.error(d.Constants.errTypeMap[e.type],e.message),new Error(e.message);o.default.warn(e.errno,`Failed to search for package "${t}" from "${n}",`,e.message)}}throw o.default.error("NOTFOUND",`package "${t}" not found from all the registries ${e.join(", ")}`),new Error(`FetchPackageInfo: ${t} failed`)}))};let m=1;function $(){const e=n.config.get(n.types.FETCH_TIMEOUT);return e||g.defaultConfig.fetch_timeout}function v(e){return y.get(e)}function w(t){return e(this,void 0,void 0,(function*(){const e=function(){const e=n.config.get(n.types.KEY_PATH);if(null==e||!e.length)throw new Error(`The ${n.types.KEY_PATH} is empty - configure ${n.types.KEY_PATH} in the ${d.Constants.PmRc} file.`);if(!f.default.existsSync(e))throw new Error(`The file in "${e}" does not exist - check ${n.types.KEY_PATH} in the ${d.Constants.PmRc} file.`);return e}(),c=function(){const e=n.config.get(n.types.PUBLISH_ID);if(null==e||!e.length)throw new Error(`The ${n.types.PUBLISH_ID} is empty - configure ${n.types.PUBLISH_ID} in ${d.Constants.PmRc} file.`);return e}(),g=Date.now(),l=(0,u.v4)().replace(/-/g,""),p=function(e,t,r,i){const u=s.FsUtil.readFileSync(e,"utf-8");if(null==u||!u.length)throw new Error(`The content of private key in "${e}" is empty - check ${n.types.KEY_PATH} in the ${d.Constants.PmRc} file.`);const c=a.default.createSign("RSA-SHA256");c.update(`v1-${t}-${r}-${i}`);let f="";if(-1===u.indexOf("ENCRYPTED"))throw o.default.error("","Private key without passphrase is not supported."),o.default.error("","You must config a encrypted private key using a non-empty passphrase."),new Error("Not supported private key.");try{for(f=x(c,u);"error"===f;)f=x(c,u);return f}catch(e){throw new Error("An unknown error occurred while getting the signature.")}}(e,c,g,l),h={};h.publishId=c,h.timestamp=g,h.nonce=l,h.signature=p,h.version="v1";const y=yield(0,r.default)(t.concat("login"),{headers:{command:"login",version:"v1","user-agent":P(),authorization:"","Content-Type":"application/json; charset=UTF-8"},body:JSON.stringify(h),method:"POST",agent:(0,i.getProxyAgent)(t)});if(!y.ok){if(400!==y.status)o.default.error(`HttpCode ${y.status}`,y.statusText);else{const e=yield y.json();o.default.error(`HttpCode ${y.status}`,`${e.error}`)}throw new Error("Login failed")}return y.json()}))}function x(e,t){const r=c.default.question("what is your passphrase of the private key: ",{hideEchoBack:!0});try{return e.sign({key:t,passphrase:r},"base64")}catch(e){return o.default.error("",`The content of private key in the ${n.types.KEY_PATH} error.`),"error"}}function P(){return`${d.Constants.PM}/${d.Constants.PmVersion} node/${process.versions.node}`}exports.fetchPackage=function(t,n,s){return e(this,void 0,void 0,(function*(){let e=yield(0,r.default)(t,{agent:(0,i.getProxyAgent)(t),redirect:"manual"});if(e.ok)return o.default.info("fetch package done  "+m++,n,t),e.buffer();const a=e.headers.get("location");if([301,302].includes(e.status)&&a)try{if(e=yield(0,r.default)(a,{agent:(0,i.getProxyAgent)(a),timeout:$()}),e.ok)return o.default.info("fetch package done  "+m++,n,a),e.buffer()}catch(e){throw o.default.error("",`Fetch package: ${n}@${s} error,`,e.message),""}throw new Error(`GET '${t}' failed, response.status = ${e.status}, ${e.statusText}`)}))},exports.getFetchTimeout=$,exports.unpublishPackage=function(t,n,s){return e(this,void 0,void 0,(function*(){const a=yield w(s);return yield function(t,n,s,a){return e(this,void 0,void 0,(function*(){const e=yield(0,r.default)(t.concat(s),{headers:{command:"unpublish",version:"v1","user-agent":P(),authorization:n.token,"Content-Type":"application/json; charset=UTF-8"},body:JSON.stringify({version:a}),method:"DELETE",agent:(0,i.getProxyAgent)(t)});if(!e.ok){if(400!==e.status)o.default.error(`HttpCode ${e.status}`,e.statusText);else{const t=yield e.json();o.default.error(`HttpCode ${e.status}`,`${t.error}`)}throw new Error("Unpublish failed")}return e.json()}))}(s,a,t,n),"ok"}))},exports.publishPackage=function(t,n){return e(this,void 0,void 0,(function*(){const s=yield w(n);return yield function(t,n,s){return e(this,void 0,void 0,(function*(){const e=s.name.replace("/","%2f"),a=yield(0,r.default)(t.concat(e),{headers:{command:"publish",version:"v1","user-agent":P(),authorization:n.token,"Content-Type":"application/json; charset=UTF-8"},body:JSON.stringify(s),method:"PUT",agent:(0,i.getProxyAgent)(t)});if(!a.ok){if(400!==a.status)o.default.error(`HttpCode ${a.status}`,a.statusText);else{const e=yield a.json();o.default.error(`HttpCode ${a.status}`,`${e.error}`)}throw new Error("Publish failed")}return a.json()}))}(n,s,t),"ok"}))},exports.getDownloadRegistry=v,exports.getUserAgent=P,exports.checkRegistry=function(e,t,r){const n=r.versions[t];if(n&&!n._ohpmVersion){const t=v(e);if(t&&!l.PmConfig.registryWhiteList.includes(t))throw o.default.error("",`${d.Constants.PM} tool does not support this registry ${t}.`),new Error("")}};